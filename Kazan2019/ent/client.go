// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/qin-guan/WorldSkills/Kazan2019/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/asset"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/assetgroup"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/assetphoto"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/assettransferlog"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/department"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/departmentlocation"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/employee"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/location"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Asset is the client for interacting with the Asset builders.
	Asset *AssetClient
	// AssetGroup is the client for interacting with the AssetGroup builders.
	AssetGroup *AssetGroupClient
	// AssetPhoto is the client for interacting with the AssetPhoto builders.
	AssetPhoto *AssetPhotoClient
	// AssetTransferLog is the client for interacting with the AssetTransferLog builders.
	AssetTransferLog *AssetTransferLogClient
	// Department is the client for interacting with the Department builders.
	Department *DepartmentClient
	// DepartmentLocation is the client for interacting with the DepartmentLocation builders.
	DepartmentLocation *DepartmentLocationClient
	// Employee is the client for interacting with the Employee builders.
	Employee *EmployeeClient
	// Location is the client for interacting with the Location builders.
	Location *LocationClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Asset = NewAssetClient(c.config)
	c.AssetGroup = NewAssetGroupClient(c.config)
	c.AssetPhoto = NewAssetPhotoClient(c.config)
	c.AssetTransferLog = NewAssetTransferLogClient(c.config)
	c.Department = NewDepartmentClient(c.config)
	c.DepartmentLocation = NewDepartmentLocationClient(c.config)
	c.Employee = NewEmployeeClient(c.config)
	c.Location = NewLocationClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Asset:              NewAssetClient(cfg),
		AssetGroup:         NewAssetGroupClient(cfg),
		AssetPhoto:         NewAssetPhotoClient(cfg),
		AssetTransferLog:   NewAssetTransferLogClient(cfg),
		Department:         NewDepartmentClient(cfg),
		DepartmentLocation: NewDepartmentLocationClient(cfg),
		Employee:           NewEmployeeClient(cfg),
		Location:           NewLocationClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Asset:              NewAssetClient(cfg),
		AssetGroup:         NewAssetGroupClient(cfg),
		AssetPhoto:         NewAssetPhotoClient(cfg),
		AssetTransferLog:   NewAssetTransferLogClient(cfg),
		Department:         NewDepartmentClient(cfg),
		DepartmentLocation: NewDepartmentLocationClient(cfg),
		Employee:           NewEmployeeClient(cfg),
		Location:           NewLocationClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Asset.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Asset, c.AssetGroup, c.AssetPhoto, c.AssetTransferLog, c.Department,
		c.DepartmentLocation, c.Employee, c.Location,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Asset, c.AssetGroup, c.AssetPhoto, c.AssetTransferLog, c.Department,
		c.DepartmentLocation, c.Employee, c.Location,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AssetMutation:
		return c.Asset.mutate(ctx, m)
	case *AssetGroupMutation:
		return c.AssetGroup.mutate(ctx, m)
	case *AssetPhotoMutation:
		return c.AssetPhoto.mutate(ctx, m)
	case *AssetTransferLogMutation:
		return c.AssetTransferLog.mutate(ctx, m)
	case *DepartmentMutation:
		return c.Department.mutate(ctx, m)
	case *DepartmentLocationMutation:
		return c.DepartmentLocation.mutate(ctx, m)
	case *EmployeeMutation:
		return c.Employee.mutate(ctx, m)
	case *LocationMutation:
		return c.Location.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AssetClient is a client for the Asset schema.
type AssetClient struct {
	config
}

// NewAssetClient returns a client for the Asset from the given config.
func NewAssetClient(c config) *AssetClient {
	return &AssetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `asset.Hooks(f(g(h())))`.
func (c *AssetClient) Use(hooks ...Hook) {
	c.hooks.Asset = append(c.hooks.Asset, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `asset.Intercept(f(g(h())))`.
func (c *AssetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Asset = append(c.inters.Asset, interceptors...)
}

// Create returns a builder for creating a Asset entity.
func (c *AssetClient) Create() *AssetCreate {
	mutation := newAssetMutation(c.config, OpCreate)
	return &AssetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Asset entities.
func (c *AssetClient) CreateBulk(builders ...*AssetCreate) *AssetCreateBulk {
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Asset.
func (c *AssetClient) Update() *AssetUpdate {
	mutation := newAssetMutation(c.config, OpUpdate)
	return &AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetClient) UpdateOne(a *Asset) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAsset(a))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetClient) UpdateOneID(id int) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAssetID(id))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Asset.
func (c *AssetClient) Delete() *AssetDelete {
	mutation := newAssetMutation(c.config, OpDelete)
	return &AssetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetClient) DeleteOne(a *Asset) *AssetDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetClient) DeleteOneID(id int) *AssetDeleteOne {
	builder := c.Delete().Where(asset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetDeleteOne{builder}
}

// Query returns a query builder for Asset.
func (c *AssetClient) Query() *AssetQuery {
	return &AssetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAsset},
		inters: c.Interceptors(),
	}
}

// Get returns a Asset entity by its id.
func (c *AssetClient) Get(ctx context.Context, id int) (*Asset, error) {
	return c.Query().Where(asset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetClient) GetX(ctx context.Context, id int) *Asset {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssetPhoto queries the AssetPhoto edge of a Asset.
func (c *AssetClient) QueryAssetPhoto(a *Asset) *AssetPhotoQuery {
	query := (&AssetPhotoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(assetphoto.Table, assetphoto.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.AssetPhotoTable, asset.AssetPhotoColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssetTransferLog queries the AssetTransferLog edge of a Asset.
func (c *AssetClient) QueryAssetTransferLog(a *Asset) *AssetTransferLogQuery {
	query := (&AssetTransferLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(assettransferlog.Table, assettransferlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.AssetTransferLogTable, asset.AssetTransferLogColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartmentLocation queries the DepartmentLocation edge of a Asset.
func (c *AssetClient) QueryDepartmentLocation(a *Asset) *DepartmentLocationQuery {
	query := (&DepartmentLocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(departmentlocation.Table, departmentlocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.DepartmentLocationTable, asset.DepartmentLocationColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmployee queries the Employee edge of a Asset.
func (c *AssetClient) QueryEmployee(a *Asset) *EmployeeQuery {
	query := (&EmployeeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(employee.Table, employee.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.EmployeeTable, asset.EmployeeColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssetGroup queries the AssetGroup edge of a Asset.
func (c *AssetClient) QueryAssetGroup(a *Asset) *AssetGroupQuery {
	query := (&AssetGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(assetgroup.Table, assetgroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, asset.AssetGroupTable, asset.AssetGroupColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetClient) Hooks() []Hook {
	return c.hooks.Asset
}

// Interceptors returns the client interceptors.
func (c *AssetClient) Interceptors() []Interceptor {
	return c.inters.Asset
}

func (c *AssetClient) mutate(ctx context.Context, m *AssetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Asset mutation op: %q", m.Op())
	}
}

// AssetGroupClient is a client for the AssetGroup schema.
type AssetGroupClient struct {
	config
}

// NewAssetGroupClient returns a client for the AssetGroup from the given config.
func NewAssetGroupClient(c config) *AssetGroupClient {
	return &AssetGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assetgroup.Hooks(f(g(h())))`.
func (c *AssetGroupClient) Use(hooks ...Hook) {
	c.hooks.AssetGroup = append(c.hooks.AssetGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assetgroup.Intercept(f(g(h())))`.
func (c *AssetGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssetGroup = append(c.inters.AssetGroup, interceptors...)
}

// Create returns a builder for creating a AssetGroup entity.
func (c *AssetGroupClient) Create() *AssetGroupCreate {
	mutation := newAssetGroupMutation(c.config, OpCreate)
	return &AssetGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssetGroup entities.
func (c *AssetGroupClient) CreateBulk(builders ...*AssetGroupCreate) *AssetGroupCreateBulk {
	return &AssetGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssetGroup.
func (c *AssetGroupClient) Update() *AssetGroupUpdate {
	mutation := newAssetGroupMutation(c.config, OpUpdate)
	return &AssetGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetGroupClient) UpdateOne(ag *AssetGroup) *AssetGroupUpdateOne {
	mutation := newAssetGroupMutation(c.config, OpUpdateOne, withAssetGroup(ag))
	return &AssetGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetGroupClient) UpdateOneID(id int) *AssetGroupUpdateOne {
	mutation := newAssetGroupMutation(c.config, OpUpdateOne, withAssetGroupID(id))
	return &AssetGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssetGroup.
func (c *AssetGroupClient) Delete() *AssetGroupDelete {
	mutation := newAssetGroupMutation(c.config, OpDelete)
	return &AssetGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetGroupClient) DeleteOne(ag *AssetGroup) *AssetGroupDeleteOne {
	return c.DeleteOneID(ag.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetGroupClient) DeleteOneID(id int) *AssetGroupDeleteOne {
	builder := c.Delete().Where(assetgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetGroupDeleteOne{builder}
}

// Query returns a query builder for AssetGroup.
func (c *AssetGroupClient) Query() *AssetGroupQuery {
	return &AssetGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssetGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a AssetGroup entity by its id.
func (c *AssetGroupClient) Get(ctx context.Context, id int) (*AssetGroup, error) {
	return c.Query().Where(assetgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetGroupClient) GetX(ctx context.Context, id int) *AssetGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsset queries the Asset edge of a AssetGroup.
func (c *AssetGroupClient) QueryAsset(ag *AssetGroup) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ag.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assetgroup.Table, assetgroup.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assetgroup.AssetTable, assetgroup.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(ag.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetGroupClient) Hooks() []Hook {
	return c.hooks.AssetGroup
}

// Interceptors returns the client interceptors.
func (c *AssetGroupClient) Interceptors() []Interceptor {
	return c.inters.AssetGroup
}

func (c *AssetGroupClient) mutate(ctx context.Context, m *AssetGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AssetGroup mutation op: %q", m.Op())
	}
}

// AssetPhotoClient is a client for the AssetPhoto schema.
type AssetPhotoClient struct {
	config
}

// NewAssetPhotoClient returns a client for the AssetPhoto from the given config.
func NewAssetPhotoClient(c config) *AssetPhotoClient {
	return &AssetPhotoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assetphoto.Hooks(f(g(h())))`.
func (c *AssetPhotoClient) Use(hooks ...Hook) {
	c.hooks.AssetPhoto = append(c.hooks.AssetPhoto, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assetphoto.Intercept(f(g(h())))`.
func (c *AssetPhotoClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssetPhoto = append(c.inters.AssetPhoto, interceptors...)
}

// Create returns a builder for creating a AssetPhoto entity.
func (c *AssetPhotoClient) Create() *AssetPhotoCreate {
	mutation := newAssetPhotoMutation(c.config, OpCreate)
	return &AssetPhotoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssetPhoto entities.
func (c *AssetPhotoClient) CreateBulk(builders ...*AssetPhotoCreate) *AssetPhotoCreateBulk {
	return &AssetPhotoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssetPhoto.
func (c *AssetPhotoClient) Update() *AssetPhotoUpdate {
	mutation := newAssetPhotoMutation(c.config, OpUpdate)
	return &AssetPhotoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetPhotoClient) UpdateOne(ap *AssetPhoto) *AssetPhotoUpdateOne {
	mutation := newAssetPhotoMutation(c.config, OpUpdateOne, withAssetPhoto(ap))
	return &AssetPhotoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetPhotoClient) UpdateOneID(id int) *AssetPhotoUpdateOne {
	mutation := newAssetPhotoMutation(c.config, OpUpdateOne, withAssetPhotoID(id))
	return &AssetPhotoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssetPhoto.
func (c *AssetPhotoClient) Delete() *AssetPhotoDelete {
	mutation := newAssetPhotoMutation(c.config, OpDelete)
	return &AssetPhotoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetPhotoClient) DeleteOne(ap *AssetPhoto) *AssetPhotoDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetPhotoClient) DeleteOneID(id int) *AssetPhotoDeleteOne {
	builder := c.Delete().Where(assetphoto.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetPhotoDeleteOne{builder}
}

// Query returns a query builder for AssetPhoto.
func (c *AssetPhotoClient) Query() *AssetPhotoQuery {
	return &AssetPhotoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssetPhoto},
		inters: c.Interceptors(),
	}
}

// Get returns a AssetPhoto entity by its id.
func (c *AssetPhotoClient) Get(ctx context.Context, id int) (*AssetPhoto, error) {
	return c.Query().Where(assetphoto.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetPhotoClient) GetX(ctx context.Context, id int) *AssetPhoto {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsset queries the Asset edge of a AssetPhoto.
func (c *AssetPhotoClient) QueryAsset(ap *AssetPhoto) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assetphoto.Table, assetphoto.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assetphoto.AssetTable, assetphoto.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetPhotoClient) Hooks() []Hook {
	return c.hooks.AssetPhoto
}

// Interceptors returns the client interceptors.
func (c *AssetPhotoClient) Interceptors() []Interceptor {
	return c.inters.AssetPhoto
}

func (c *AssetPhotoClient) mutate(ctx context.Context, m *AssetPhotoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetPhotoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetPhotoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetPhotoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetPhotoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AssetPhoto mutation op: %q", m.Op())
	}
}

// AssetTransferLogClient is a client for the AssetTransferLog schema.
type AssetTransferLogClient struct {
	config
}

// NewAssetTransferLogClient returns a client for the AssetTransferLog from the given config.
func NewAssetTransferLogClient(c config) *AssetTransferLogClient {
	return &AssetTransferLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assettransferlog.Hooks(f(g(h())))`.
func (c *AssetTransferLogClient) Use(hooks ...Hook) {
	c.hooks.AssetTransferLog = append(c.hooks.AssetTransferLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `assettransferlog.Intercept(f(g(h())))`.
func (c *AssetTransferLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AssetTransferLog = append(c.inters.AssetTransferLog, interceptors...)
}

// Create returns a builder for creating a AssetTransferLog entity.
func (c *AssetTransferLogClient) Create() *AssetTransferLogCreate {
	mutation := newAssetTransferLogMutation(c.config, OpCreate)
	return &AssetTransferLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssetTransferLog entities.
func (c *AssetTransferLogClient) CreateBulk(builders ...*AssetTransferLogCreate) *AssetTransferLogCreateBulk {
	return &AssetTransferLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssetTransferLog.
func (c *AssetTransferLogClient) Update() *AssetTransferLogUpdate {
	mutation := newAssetTransferLogMutation(c.config, OpUpdate)
	return &AssetTransferLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetTransferLogClient) UpdateOne(atl *AssetTransferLog) *AssetTransferLogUpdateOne {
	mutation := newAssetTransferLogMutation(c.config, OpUpdateOne, withAssetTransferLog(atl))
	return &AssetTransferLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetTransferLogClient) UpdateOneID(id int) *AssetTransferLogUpdateOne {
	mutation := newAssetTransferLogMutation(c.config, OpUpdateOne, withAssetTransferLogID(id))
	return &AssetTransferLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssetTransferLog.
func (c *AssetTransferLogClient) Delete() *AssetTransferLogDelete {
	mutation := newAssetTransferLogMutation(c.config, OpDelete)
	return &AssetTransferLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetTransferLogClient) DeleteOne(atl *AssetTransferLog) *AssetTransferLogDeleteOne {
	return c.DeleteOneID(atl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AssetTransferLogClient) DeleteOneID(id int) *AssetTransferLogDeleteOne {
	builder := c.Delete().Where(assettransferlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetTransferLogDeleteOne{builder}
}

// Query returns a query builder for AssetTransferLog.
func (c *AssetTransferLogClient) Query() *AssetTransferLogQuery {
	return &AssetTransferLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAssetTransferLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AssetTransferLog entity by its id.
func (c *AssetTransferLogClient) Get(ctx context.Context, id int) (*AssetTransferLog, error) {
	return c.Query().Where(assettransferlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetTransferLogClient) GetX(ctx context.Context, id int) *AssetTransferLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsset queries the Asset edge of a AssetTransferLog.
func (c *AssetTransferLogClient) QueryAsset(atl *AssetTransferLog) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := atl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assettransferlog.Table, assettransferlog.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assettransferlog.AssetTable, assettransferlog.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(atl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFromDepartmentLocation queries the FromDepartmentLocation edge of a AssetTransferLog.
func (c *AssetTransferLogClient) QueryFromDepartmentLocation(atl *AssetTransferLog) *DepartmentLocationQuery {
	query := (&DepartmentLocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := atl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assettransferlog.Table, assettransferlog.FieldID, id),
			sqlgraph.To(departmentlocation.Table, departmentlocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assettransferlog.FromDepartmentLocationTable, assettransferlog.FromDepartmentLocationColumn),
		)
		fromV = sqlgraph.Neighbors(atl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToDepartmentLocation queries the ToDepartmentLocation edge of a AssetTransferLog.
func (c *AssetTransferLogClient) QueryToDepartmentLocation(atl *AssetTransferLog) *DepartmentLocationQuery {
	query := (&DepartmentLocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := atl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assettransferlog.Table, assettransferlog.FieldID, id),
			sqlgraph.To(departmentlocation.Table, departmentlocation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assettransferlog.ToDepartmentLocationTable, assettransferlog.ToDepartmentLocationColumn),
		)
		fromV = sqlgraph.Neighbors(atl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetTransferLogClient) Hooks() []Hook {
	return c.hooks.AssetTransferLog
}

// Interceptors returns the client interceptors.
func (c *AssetTransferLogClient) Interceptors() []Interceptor {
	return c.inters.AssetTransferLog
}

func (c *AssetTransferLogClient) mutate(ctx context.Context, m *AssetTransferLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AssetTransferLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AssetTransferLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AssetTransferLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AssetTransferLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AssetTransferLog mutation op: %q", m.Op())
	}
}

// DepartmentClient is a client for the Department schema.
type DepartmentClient struct {
	config
}

// NewDepartmentClient returns a client for the Department from the given config.
func NewDepartmentClient(c config) *DepartmentClient {
	return &DepartmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `department.Hooks(f(g(h())))`.
func (c *DepartmentClient) Use(hooks ...Hook) {
	c.hooks.Department = append(c.hooks.Department, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `department.Intercept(f(g(h())))`.
func (c *DepartmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Department = append(c.inters.Department, interceptors...)
}

// Create returns a builder for creating a Department entity.
func (c *DepartmentClient) Create() *DepartmentCreate {
	mutation := newDepartmentMutation(c.config, OpCreate)
	return &DepartmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Department entities.
func (c *DepartmentClient) CreateBulk(builders ...*DepartmentCreate) *DepartmentCreateBulk {
	return &DepartmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Department.
func (c *DepartmentClient) Update() *DepartmentUpdate {
	mutation := newDepartmentMutation(c.config, OpUpdate)
	return &DepartmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DepartmentClient) UpdateOne(d *Department) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartment(d))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DepartmentClient) UpdateOneID(id int) *DepartmentUpdateOne {
	mutation := newDepartmentMutation(c.config, OpUpdateOne, withDepartmentID(id))
	return &DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Department.
func (c *DepartmentClient) Delete() *DepartmentDelete {
	mutation := newDepartmentMutation(c.config, OpDelete)
	return &DepartmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DepartmentClient) DeleteOne(d *Department) *DepartmentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DepartmentClient) DeleteOneID(id int) *DepartmentDeleteOne {
	builder := c.Delete().Where(department.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DepartmentDeleteOne{builder}
}

// Query returns a query builder for Department.
func (c *DepartmentClient) Query() *DepartmentQuery {
	return &DepartmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDepartment},
		inters: c.Interceptors(),
	}
}

// Get returns a Department entity by its id.
func (c *DepartmentClient) Get(ctx context.Context, id int) (*Department, error) {
	return c.Query().Where(department.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DepartmentClient) GetX(ctx context.Context, id int) *Department {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDepartmentLocation queries the DepartmentLocation edge of a Department.
func (c *DepartmentClient) QueryDepartmentLocation(d *Department) *DepartmentLocationQuery {
	query := (&DepartmentLocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(department.Table, department.FieldID, id),
			sqlgraph.To(departmentlocation.Table, departmentlocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, department.DepartmentLocationTable, department.DepartmentLocationColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DepartmentClient) Hooks() []Hook {
	return c.hooks.Department
}

// Interceptors returns the client interceptors.
func (c *DepartmentClient) Interceptors() []Interceptor {
	return c.inters.Department
}

func (c *DepartmentClient) mutate(ctx context.Context, m *DepartmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DepartmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DepartmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DepartmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DepartmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Department mutation op: %q", m.Op())
	}
}

// DepartmentLocationClient is a client for the DepartmentLocation schema.
type DepartmentLocationClient struct {
	config
}

// NewDepartmentLocationClient returns a client for the DepartmentLocation from the given config.
func NewDepartmentLocationClient(c config) *DepartmentLocationClient {
	return &DepartmentLocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `departmentlocation.Hooks(f(g(h())))`.
func (c *DepartmentLocationClient) Use(hooks ...Hook) {
	c.hooks.DepartmentLocation = append(c.hooks.DepartmentLocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `departmentlocation.Intercept(f(g(h())))`.
func (c *DepartmentLocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.DepartmentLocation = append(c.inters.DepartmentLocation, interceptors...)
}

// Create returns a builder for creating a DepartmentLocation entity.
func (c *DepartmentLocationClient) Create() *DepartmentLocationCreate {
	mutation := newDepartmentLocationMutation(c.config, OpCreate)
	return &DepartmentLocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DepartmentLocation entities.
func (c *DepartmentLocationClient) CreateBulk(builders ...*DepartmentLocationCreate) *DepartmentLocationCreateBulk {
	return &DepartmentLocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DepartmentLocation.
func (c *DepartmentLocationClient) Update() *DepartmentLocationUpdate {
	mutation := newDepartmentLocationMutation(c.config, OpUpdate)
	return &DepartmentLocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DepartmentLocationClient) UpdateOne(dl *DepartmentLocation) *DepartmentLocationUpdateOne {
	mutation := newDepartmentLocationMutation(c.config, OpUpdateOne, withDepartmentLocation(dl))
	return &DepartmentLocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DepartmentLocationClient) UpdateOneID(id int) *DepartmentLocationUpdateOne {
	mutation := newDepartmentLocationMutation(c.config, OpUpdateOne, withDepartmentLocationID(id))
	return &DepartmentLocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DepartmentLocation.
func (c *DepartmentLocationClient) Delete() *DepartmentLocationDelete {
	mutation := newDepartmentLocationMutation(c.config, OpDelete)
	return &DepartmentLocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DepartmentLocationClient) DeleteOne(dl *DepartmentLocation) *DepartmentLocationDeleteOne {
	return c.DeleteOneID(dl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DepartmentLocationClient) DeleteOneID(id int) *DepartmentLocationDeleteOne {
	builder := c.Delete().Where(departmentlocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DepartmentLocationDeleteOne{builder}
}

// Query returns a query builder for DepartmentLocation.
func (c *DepartmentLocationClient) Query() *DepartmentLocationQuery {
	return &DepartmentLocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDepartmentLocation},
		inters: c.Interceptors(),
	}
}

// Get returns a DepartmentLocation entity by its id.
func (c *DepartmentLocationClient) Get(ctx context.Context, id int) (*DepartmentLocation, error) {
	return c.Query().Where(departmentlocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DepartmentLocationClient) GetX(ctx context.Context, id int) *DepartmentLocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsset queries the Asset edge of a DepartmentLocation.
func (c *DepartmentLocationClient) QueryAsset(dl *DepartmentLocation) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(departmentlocation.Table, departmentlocation.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, departmentlocation.AssetTable, departmentlocation.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(dl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFromDepartmentLocation queries the FromDepartmentLocation edge of a DepartmentLocation.
func (c *DepartmentLocationClient) QueryFromDepartmentLocation(dl *DepartmentLocation) *AssetTransferLogQuery {
	query := (&AssetTransferLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(departmentlocation.Table, departmentlocation.FieldID, id),
			sqlgraph.To(assettransferlog.Table, assettransferlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, departmentlocation.FromDepartmentLocationTable, departmentlocation.FromDepartmentLocationColumn),
		)
		fromV = sqlgraph.Neighbors(dl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToDepartmentLocation queries the ToDepartmentLocation edge of a DepartmentLocation.
func (c *DepartmentLocationClient) QueryToDepartmentLocation(dl *DepartmentLocation) *AssetTransferLogQuery {
	query := (&AssetTransferLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(departmentlocation.Table, departmentlocation.FieldID, id),
			sqlgraph.To(assettransferlog.Table, assettransferlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, departmentlocation.ToDepartmentLocationTable, departmentlocation.ToDepartmentLocationColumn),
		)
		fromV = sqlgraph.Neighbors(dl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDepartment queries the Department edge of a DepartmentLocation.
func (c *DepartmentLocationClient) QueryDepartment(dl *DepartmentLocation) *DepartmentQuery {
	query := (&DepartmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(departmentlocation.Table, departmentlocation.FieldID, id),
			sqlgraph.To(department.Table, department.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, departmentlocation.DepartmentTable, departmentlocation.DepartmentColumn),
		)
		fromV = sqlgraph.Neighbors(dl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the Location edge of a DepartmentLocation.
func (c *DepartmentLocationClient) QueryLocation(dl *DepartmentLocation) *LocationQuery {
	query := (&LocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(departmentlocation.Table, departmentlocation.FieldID, id),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, departmentlocation.LocationTable, departmentlocation.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(dl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DepartmentLocationClient) Hooks() []Hook {
	return c.hooks.DepartmentLocation
}

// Interceptors returns the client interceptors.
func (c *DepartmentLocationClient) Interceptors() []Interceptor {
	return c.inters.DepartmentLocation
}

func (c *DepartmentLocationClient) mutate(ctx context.Context, m *DepartmentLocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DepartmentLocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DepartmentLocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DepartmentLocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DepartmentLocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DepartmentLocation mutation op: %q", m.Op())
	}
}

// EmployeeClient is a client for the Employee schema.
type EmployeeClient struct {
	config
}

// NewEmployeeClient returns a client for the Employee from the given config.
func NewEmployeeClient(c config) *EmployeeClient {
	return &EmployeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `employee.Hooks(f(g(h())))`.
func (c *EmployeeClient) Use(hooks ...Hook) {
	c.hooks.Employee = append(c.hooks.Employee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `employee.Intercept(f(g(h())))`.
func (c *EmployeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Employee = append(c.inters.Employee, interceptors...)
}

// Create returns a builder for creating a Employee entity.
func (c *EmployeeClient) Create() *EmployeeCreate {
	mutation := newEmployeeMutation(c.config, OpCreate)
	return &EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Employee entities.
func (c *EmployeeClient) CreateBulk(builders ...*EmployeeCreate) *EmployeeCreateBulk {
	return &EmployeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Employee.
func (c *EmployeeClient) Update() *EmployeeUpdate {
	mutation := newEmployeeMutation(c.config, OpUpdate)
	return &EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmployeeClient) UpdateOne(e *Employee) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployee(e))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmployeeClient) UpdateOneID(id int) *EmployeeUpdateOne {
	mutation := newEmployeeMutation(c.config, OpUpdateOne, withEmployeeID(id))
	return &EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Employee.
func (c *EmployeeClient) Delete() *EmployeeDelete {
	mutation := newEmployeeMutation(c.config, OpDelete)
	return &EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmployeeClient) DeleteOne(e *Employee) *EmployeeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmployeeClient) DeleteOneID(id int) *EmployeeDeleteOne {
	builder := c.Delete().Where(employee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmployeeDeleteOne{builder}
}

// Query returns a query builder for Employee.
func (c *EmployeeClient) Query() *EmployeeQuery {
	return &EmployeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmployee},
		inters: c.Interceptors(),
	}
}

// Get returns a Employee entity by its id.
func (c *EmployeeClient) Get(ctx context.Context, id int) (*Employee, error) {
	return c.Query().Where(employee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmployeeClient) GetX(ctx context.Context, id int) *Employee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsset queries the Asset edge of a Employee.
func (c *EmployeeClient) QueryAsset(e *Employee) *AssetQuery {
	query := (&AssetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(employee.Table, employee.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, employee.AssetTable, employee.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmployeeClient) Hooks() []Hook {
	return c.hooks.Employee
}

// Interceptors returns the client interceptors.
func (c *EmployeeClient) Interceptors() []Interceptor {
	return c.inters.Employee
}

func (c *EmployeeClient) mutate(ctx context.Context, m *EmployeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmployeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmployeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmployeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmployeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Employee mutation op: %q", m.Op())
	}
}

// LocationClient is a client for the Location schema.
type LocationClient struct {
	config
}

// NewLocationClient returns a client for the Location from the given config.
func NewLocationClient(c config) *LocationClient {
	return &LocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `location.Hooks(f(g(h())))`.
func (c *LocationClient) Use(hooks ...Hook) {
	c.hooks.Location = append(c.hooks.Location, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `location.Intercept(f(g(h())))`.
func (c *LocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Location = append(c.inters.Location, interceptors...)
}

// Create returns a builder for creating a Location entity.
func (c *LocationClient) Create() *LocationCreate {
	mutation := newLocationMutation(c.config, OpCreate)
	return &LocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Location entities.
func (c *LocationClient) CreateBulk(builders ...*LocationCreate) *LocationCreateBulk {
	return &LocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Location.
func (c *LocationClient) Update() *LocationUpdate {
	mutation := newLocationMutation(c.config, OpUpdate)
	return &LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocationClient) UpdateOne(l *Location) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocation(l))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocationClient) UpdateOneID(id int) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocationID(id))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Location.
func (c *LocationClient) Delete() *LocationDelete {
	mutation := newLocationMutation(c.config, OpDelete)
	return &LocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LocationClient) DeleteOne(l *Location) *LocationDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LocationClient) DeleteOneID(id int) *LocationDeleteOne {
	builder := c.Delete().Where(location.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocationDeleteOne{builder}
}

// Query returns a query builder for Location.
func (c *LocationClient) Query() *LocationQuery {
	return &LocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLocation},
		inters: c.Interceptors(),
	}
}

// Get returns a Location entity by its id.
func (c *LocationClient) Get(ctx context.Context, id int) (*Location, error) {
	return c.Query().Where(location.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocationClient) GetX(ctx context.Context, id int) *Location {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDepartmentLocation queries the DepartmentLocation edge of a Location.
func (c *LocationClient) QueryDepartmentLocation(l *Location) *DepartmentLocationQuery {
	query := (&DepartmentLocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(departmentlocation.Table, departmentlocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, location.DepartmentLocationTable, location.DepartmentLocationColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LocationClient) Hooks() []Hook {
	return c.hooks.Location
}

// Interceptors returns the client interceptors.
func (c *LocationClient) Interceptors() []Interceptor {
	return c.inters.Location
}

func (c *LocationClient) mutate(ctx context.Context, m *LocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Location mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Asset, AssetGroup, AssetPhoto, AssetTransferLog, Department, DepartmentLocation,
		Employee, Location []ent.Hook
	}
	inters struct {
		Asset, AssetGroup, AssetPhoto, AssetTransferLog, Department, DepartmentLocation,
		Employee, Location []ent.Interceptor
	}
)

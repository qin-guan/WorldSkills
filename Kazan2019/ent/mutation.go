// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/asset"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/assetgroup"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/assetphoto"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/assettransferlog"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/department"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/departmentlocation"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/employee"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/location"
	"github.com/qin-guan/WorldSkills/Kazan2019/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAsset              = "Asset"
	TypeAssetGroup         = "AssetGroup"
	TypeAssetPhoto         = "AssetPhoto"
	TypeAssetTransferLog   = "AssetTransferLog"
	TypeDepartment         = "Department"
	TypeDepartmentLocation = "DepartmentLocation"
	TypeEmployee           = "Employee"
	TypeLocation           = "Location"
)

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_AssetSN                   *int
	add_AssetSN                *int
	_AssetName                 *string
	_Description               *string
	_WarrantyDate              *time.Time
	clearedFields              map[string]struct{}
	_AssetPhoto                map[int]struct{}
	removed_AssetPhoto         map[int]struct{}
	cleared_AssetPhoto         bool
	_AssetTransferLog          map[int]struct{}
	removed_AssetTransferLog   map[int]struct{}
	cleared_AssetTransferLog   bool
	_DepartmentLocation        *int
	cleared_DepartmentLocation bool
	_Employee                  *int
	cleared_Employee           bool
	_AssetGroup                *int
	cleared_AssetGroup         bool
	done                       bool
	oldValue                   func(context.Context) (*Asset, error)
	predicates                 []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id int) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAssetGroupID sets the "AssetGroupID" field.
func (m *AssetMutation) SetAssetGroupID(i int) {
	m._AssetGroup = &i
}

// AssetGroupID returns the value of the "AssetGroupID" field in the mutation.
func (m *AssetMutation) AssetGroupID() (r int, exists bool) {
	v := m._AssetGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetGroupID returns the old "AssetGroupID" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAssetGroupID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetGroupID: %w", err)
	}
	return oldValue.AssetGroupID, nil
}

// ResetAssetGroupID resets all changes to the "AssetGroupID" field.
func (m *AssetMutation) ResetAssetGroupID() {
	m._AssetGroup = nil
}

// SetEmployeeID sets the "EmployeeID" field.
func (m *AssetMutation) SetEmployeeID(i int) {
	m._Employee = &i
}

// EmployeeID returns the value of the "EmployeeID" field in the mutation.
func (m *AssetMutation) EmployeeID() (r int, exists bool) {
	v := m._Employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "EmployeeID" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldEmployeeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "EmployeeID" field.
func (m *AssetMutation) ResetEmployeeID() {
	m._Employee = nil
}

// SetDepartmentLocationID sets the "DepartmentLocationID" field.
func (m *AssetMutation) SetDepartmentLocationID(i int) {
	m._DepartmentLocation = &i
}

// DepartmentLocationID returns the value of the "DepartmentLocationID" field in the mutation.
func (m *AssetMutation) DepartmentLocationID() (r int, exists bool) {
	v := m._DepartmentLocation
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentLocationID returns the old "DepartmentLocationID" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldDepartmentLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentLocationID: %w", err)
	}
	return oldValue.DepartmentLocationID, nil
}

// ResetDepartmentLocationID resets all changes to the "DepartmentLocationID" field.
func (m *AssetMutation) ResetDepartmentLocationID() {
	m._DepartmentLocation = nil
}

// SetAssetSN sets the "AssetSN" field.
func (m *AssetMutation) SetAssetSN(i int) {
	m._AssetSN = &i
	m.add_AssetSN = nil
}

// AssetSN returns the value of the "AssetSN" field in the mutation.
func (m *AssetMutation) AssetSN() (r int, exists bool) {
	v := m._AssetSN
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetSN returns the old "AssetSN" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAssetSN(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetSN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetSN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetSN: %w", err)
	}
	return oldValue.AssetSN, nil
}

// AddAssetSN adds i to the "AssetSN" field.
func (m *AssetMutation) AddAssetSN(i int) {
	if m.add_AssetSN != nil {
		*m.add_AssetSN += i
	} else {
		m.add_AssetSN = &i
	}
}

// AddedAssetSN returns the value that was added to the "AssetSN" field in this mutation.
func (m *AssetMutation) AddedAssetSN() (r int, exists bool) {
	v := m.add_AssetSN
	if v == nil {
		return
	}
	return *v, true
}

// ResetAssetSN resets all changes to the "AssetSN" field.
func (m *AssetMutation) ResetAssetSN() {
	m._AssetSN = nil
	m.add_AssetSN = nil
}

// SetAssetName sets the "AssetName" field.
func (m *AssetMutation) SetAssetName(s string) {
	m._AssetName = &s
}

// AssetName returns the value of the "AssetName" field in the mutation.
func (m *AssetMutation) AssetName() (r string, exists bool) {
	v := m._AssetName
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetName returns the old "AssetName" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAssetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetName: %w", err)
	}
	return oldValue.AssetName, nil
}

// ResetAssetName resets all changes to the "AssetName" field.
func (m *AssetMutation) ResetAssetName() {
	m._AssetName = nil
}

// SetDescription sets the "Description" field.
func (m *AssetMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *AssetMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *AssetMutation) ResetDescription() {
	m._Description = nil
}

// SetWarrantyDate sets the "WarrantyDate" field.
func (m *AssetMutation) SetWarrantyDate(t time.Time) {
	m._WarrantyDate = &t
}

// WarrantyDate returns the value of the "WarrantyDate" field in the mutation.
func (m *AssetMutation) WarrantyDate() (r time.Time, exists bool) {
	v := m._WarrantyDate
	if v == nil {
		return
	}
	return *v, true
}

// OldWarrantyDate returns the old "WarrantyDate" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldWarrantyDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarrantyDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarrantyDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarrantyDate: %w", err)
	}
	return oldValue.WarrantyDate, nil
}

// ResetWarrantyDate resets all changes to the "WarrantyDate" field.
func (m *AssetMutation) ResetWarrantyDate() {
	m._WarrantyDate = nil
}

// AddAssetPhotoIDs adds the "AssetPhoto" edge to the AssetPhoto entity by ids.
func (m *AssetMutation) AddAssetPhotoIDs(ids ...int) {
	if m._AssetPhoto == nil {
		m._AssetPhoto = make(map[int]struct{})
	}
	for i := range ids {
		m._AssetPhoto[ids[i]] = struct{}{}
	}
}

// ClearAssetPhoto clears the "AssetPhoto" edge to the AssetPhoto entity.
func (m *AssetMutation) ClearAssetPhoto() {
	m.cleared_AssetPhoto = true
}

// AssetPhotoCleared reports if the "AssetPhoto" edge to the AssetPhoto entity was cleared.
func (m *AssetMutation) AssetPhotoCleared() bool {
	return m.cleared_AssetPhoto
}

// RemoveAssetPhotoIDs removes the "AssetPhoto" edge to the AssetPhoto entity by IDs.
func (m *AssetMutation) RemoveAssetPhotoIDs(ids ...int) {
	if m.removed_AssetPhoto == nil {
		m.removed_AssetPhoto = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._AssetPhoto, ids[i])
		m.removed_AssetPhoto[ids[i]] = struct{}{}
	}
}

// RemovedAssetPhoto returns the removed IDs of the "AssetPhoto" edge to the AssetPhoto entity.
func (m *AssetMutation) RemovedAssetPhotoIDs() (ids []int) {
	for id := range m.removed_AssetPhoto {
		ids = append(ids, id)
	}
	return
}

// AssetPhotoIDs returns the "AssetPhoto" edge IDs in the mutation.
func (m *AssetMutation) AssetPhotoIDs() (ids []int) {
	for id := range m._AssetPhoto {
		ids = append(ids, id)
	}
	return
}

// ResetAssetPhoto resets all changes to the "AssetPhoto" edge.
func (m *AssetMutation) ResetAssetPhoto() {
	m._AssetPhoto = nil
	m.cleared_AssetPhoto = false
	m.removed_AssetPhoto = nil
}

// AddAssetTransferLogIDs adds the "AssetTransferLog" edge to the AssetTransferLog entity by ids.
func (m *AssetMutation) AddAssetTransferLogIDs(ids ...int) {
	if m._AssetTransferLog == nil {
		m._AssetTransferLog = make(map[int]struct{})
	}
	for i := range ids {
		m._AssetTransferLog[ids[i]] = struct{}{}
	}
}

// ClearAssetTransferLog clears the "AssetTransferLog" edge to the AssetTransferLog entity.
func (m *AssetMutation) ClearAssetTransferLog() {
	m.cleared_AssetTransferLog = true
}

// AssetTransferLogCleared reports if the "AssetTransferLog" edge to the AssetTransferLog entity was cleared.
func (m *AssetMutation) AssetTransferLogCleared() bool {
	return m.cleared_AssetTransferLog
}

// RemoveAssetTransferLogIDs removes the "AssetTransferLog" edge to the AssetTransferLog entity by IDs.
func (m *AssetMutation) RemoveAssetTransferLogIDs(ids ...int) {
	if m.removed_AssetTransferLog == nil {
		m.removed_AssetTransferLog = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._AssetTransferLog, ids[i])
		m.removed_AssetTransferLog[ids[i]] = struct{}{}
	}
}

// RemovedAssetTransferLog returns the removed IDs of the "AssetTransferLog" edge to the AssetTransferLog entity.
func (m *AssetMutation) RemovedAssetTransferLogIDs() (ids []int) {
	for id := range m.removed_AssetTransferLog {
		ids = append(ids, id)
	}
	return
}

// AssetTransferLogIDs returns the "AssetTransferLog" edge IDs in the mutation.
func (m *AssetMutation) AssetTransferLogIDs() (ids []int) {
	for id := range m._AssetTransferLog {
		ids = append(ids, id)
	}
	return
}

// ResetAssetTransferLog resets all changes to the "AssetTransferLog" edge.
func (m *AssetMutation) ResetAssetTransferLog() {
	m._AssetTransferLog = nil
	m.cleared_AssetTransferLog = false
	m.removed_AssetTransferLog = nil
}

// ClearDepartmentLocation clears the "DepartmentLocation" edge to the DepartmentLocation entity.
func (m *AssetMutation) ClearDepartmentLocation() {
	m.cleared_DepartmentLocation = true
}

// DepartmentLocationCleared reports if the "DepartmentLocation" edge to the DepartmentLocation entity was cleared.
func (m *AssetMutation) DepartmentLocationCleared() bool {
	return m.cleared_DepartmentLocation
}

// DepartmentLocationIDs returns the "DepartmentLocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentLocationID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) DepartmentLocationIDs() (ids []int) {
	if id := m._DepartmentLocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartmentLocation resets all changes to the "DepartmentLocation" edge.
func (m *AssetMutation) ResetDepartmentLocation() {
	m._DepartmentLocation = nil
	m.cleared_DepartmentLocation = false
}

// ClearEmployee clears the "Employee" edge to the Employee entity.
func (m *AssetMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared reports if the "Employee" edge to the Employee entity was cleared.
func (m *AssetMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeIDs returns the "Employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "Employee" edge.
func (m *AssetMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// ClearAssetGroup clears the "AssetGroup" edge to the AssetGroup entity.
func (m *AssetMutation) ClearAssetGroup() {
	m.cleared_AssetGroup = true
}

// AssetGroupCleared reports if the "AssetGroup" edge to the AssetGroup entity was cleared.
func (m *AssetMutation) AssetGroupCleared() bool {
	return m.cleared_AssetGroup
}

// AssetGroupIDs returns the "AssetGroup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetGroupID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) AssetGroupIDs() (ids []int) {
	if id := m._AssetGroup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssetGroup resets all changes to the "AssetGroup" edge.
func (m *AssetMutation) ResetAssetGroup() {
	m._AssetGroup = nil
	m.cleared_AssetGroup = false
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Asset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._AssetGroup != nil {
		fields = append(fields, asset.FieldAssetGroupID)
	}
	if m._Employee != nil {
		fields = append(fields, asset.FieldEmployeeID)
	}
	if m._DepartmentLocation != nil {
		fields = append(fields, asset.FieldDepartmentLocationID)
	}
	if m._AssetSN != nil {
		fields = append(fields, asset.FieldAssetSN)
	}
	if m._AssetName != nil {
		fields = append(fields, asset.FieldAssetName)
	}
	if m._Description != nil {
		fields = append(fields, asset.FieldDescription)
	}
	if m._WarrantyDate != nil {
		fields = append(fields, asset.FieldWarrantyDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldAssetGroupID:
		return m.AssetGroupID()
	case asset.FieldEmployeeID:
		return m.EmployeeID()
	case asset.FieldDepartmentLocationID:
		return m.DepartmentLocationID()
	case asset.FieldAssetSN:
		return m.AssetSN()
	case asset.FieldAssetName:
		return m.AssetName()
	case asset.FieldDescription:
		return m.Description()
	case asset.FieldWarrantyDate:
		return m.WarrantyDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldAssetGroupID:
		return m.OldAssetGroupID(ctx)
	case asset.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case asset.FieldDepartmentLocationID:
		return m.OldDepartmentLocationID(ctx)
	case asset.FieldAssetSN:
		return m.OldAssetSN(ctx)
	case asset.FieldAssetName:
		return m.OldAssetName(ctx)
	case asset.FieldDescription:
		return m.OldDescription(ctx)
	case asset.FieldWarrantyDate:
		return m.OldWarrantyDate(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldAssetGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetGroupID(v)
		return nil
	case asset.FieldEmployeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case asset.FieldDepartmentLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentLocationID(v)
		return nil
	case asset.FieldAssetSN:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetSN(v)
		return nil
	case asset.FieldAssetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetName(v)
		return nil
	case asset.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case asset.FieldWarrantyDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarrantyDate(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	var fields []string
	if m.add_AssetSN != nil {
		fields = append(fields, asset.FieldAssetSN)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldAssetSN:
		return m.AddedAssetSN()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case asset.FieldAssetSN:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssetSN(v)
		return nil
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldAssetGroupID:
		m.ResetAssetGroupID()
		return nil
	case asset.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case asset.FieldDepartmentLocationID:
		m.ResetDepartmentLocationID()
		return nil
	case asset.FieldAssetSN:
		m.ResetAssetSN()
		return nil
	case asset.FieldAssetName:
		m.ResetAssetName()
		return nil
	case asset.FieldDescription:
		m.ResetDescription()
		return nil
	case asset.FieldWarrantyDate:
		m.ResetWarrantyDate()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._AssetPhoto != nil {
		edges = append(edges, asset.EdgeAssetPhoto)
	}
	if m._AssetTransferLog != nil {
		edges = append(edges, asset.EdgeAssetTransferLog)
	}
	if m._DepartmentLocation != nil {
		edges = append(edges, asset.EdgeDepartmentLocation)
	}
	if m._Employee != nil {
		edges = append(edges, asset.EdgeEmployee)
	}
	if m._AssetGroup != nil {
		edges = append(edges, asset.EdgeAssetGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeAssetPhoto:
		ids := make([]ent.Value, 0, len(m._AssetPhoto))
		for id := range m._AssetPhoto {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeAssetTransferLog:
		ids := make([]ent.Value, 0, len(m._AssetTransferLog))
		for id := range m._AssetTransferLog {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDepartmentLocation:
		if id := m._DepartmentLocation; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeAssetGroup:
		if id := m._AssetGroup; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_AssetPhoto != nil {
		edges = append(edges, asset.EdgeAssetPhoto)
	}
	if m.removed_AssetTransferLog != nil {
		edges = append(edges, asset.EdgeAssetTransferLog)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeAssetPhoto:
		ids := make([]ent.Value, 0, len(m.removed_AssetPhoto))
		for id := range m.removed_AssetPhoto {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeAssetTransferLog:
		ids := make([]ent.Value, 0, len(m.removed_AssetTransferLog))
		for id := range m.removed_AssetTransferLog {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_AssetPhoto {
		edges = append(edges, asset.EdgeAssetPhoto)
	}
	if m.cleared_AssetTransferLog {
		edges = append(edges, asset.EdgeAssetTransferLog)
	}
	if m.cleared_DepartmentLocation {
		edges = append(edges, asset.EdgeDepartmentLocation)
	}
	if m.cleared_Employee {
		edges = append(edges, asset.EdgeEmployee)
	}
	if m.cleared_AssetGroup {
		edges = append(edges, asset.EdgeAssetGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgeAssetPhoto:
		return m.cleared_AssetPhoto
	case asset.EdgeAssetTransferLog:
		return m.cleared_AssetTransferLog
	case asset.EdgeDepartmentLocation:
		return m.cleared_DepartmentLocation
	case asset.EdgeEmployee:
		return m.cleared_Employee
	case asset.EdgeAssetGroup:
		return m.cleared_AssetGroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeDepartmentLocation:
		m.ClearDepartmentLocation()
		return nil
	case asset.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case asset.EdgeAssetGroup:
		m.ClearAssetGroup()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgeAssetPhoto:
		m.ResetAssetPhoto()
		return nil
	case asset.EdgeAssetTransferLog:
		m.ResetAssetTransferLog()
		return nil
	case asset.EdgeDepartmentLocation:
		m.ResetDepartmentLocation()
		return nil
	case asset.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case asset.EdgeAssetGroup:
		m.ResetAssetGroup()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AssetGroupMutation represents an operation that mutates the AssetGroup nodes in the graph.
type AssetGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	clearedFields map[string]struct{}
	_Asset        map[int]struct{}
	removed_Asset map[int]struct{}
	cleared_Asset bool
	done          bool
	oldValue      func(context.Context) (*AssetGroup, error)
	predicates    []predicate.AssetGroup
}

var _ ent.Mutation = (*AssetGroupMutation)(nil)

// assetgroupOption allows management of the mutation configuration using functional options.
type assetgroupOption func(*AssetGroupMutation)

// newAssetGroupMutation creates new mutation for the AssetGroup entity.
func newAssetGroupMutation(c config, op Op, opts ...assetgroupOption) *AssetGroupMutation {
	m := &AssetGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetGroupID sets the ID field of the mutation.
func withAssetGroupID(id int) assetgroupOption {
	return func(m *AssetGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetGroup
		)
		m.oldValue = func(ctx context.Context) (*AssetGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetGroup sets the old AssetGroup of the mutation.
func withAssetGroup(node *AssetGroup) assetgroupOption {
	return func(m *AssetGroupMutation) {
		m.oldValue = func(context.Context) (*AssetGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssetGroup entities.
func (m *AssetGroupMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *AssetGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *AssetGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the AssetGroup entity.
// If the AssetGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *AssetGroupMutation) ResetName() {
	m._Name = nil
}

// AddAssetIDs adds the "Asset" edge to the Asset entity by ids.
func (m *AssetGroupMutation) AddAssetIDs(ids ...int) {
	if m._Asset == nil {
		m._Asset = make(map[int]struct{})
	}
	for i := range ids {
		m._Asset[ids[i]] = struct{}{}
	}
}

// ClearAsset clears the "Asset" edge to the Asset entity.
func (m *AssetGroupMutation) ClearAsset() {
	m.cleared_Asset = true
}

// AssetCleared reports if the "Asset" edge to the Asset entity was cleared.
func (m *AssetGroupMutation) AssetCleared() bool {
	return m.cleared_Asset
}

// RemoveAssetIDs removes the "Asset" edge to the Asset entity by IDs.
func (m *AssetGroupMutation) RemoveAssetIDs(ids ...int) {
	if m.removed_Asset == nil {
		m.removed_Asset = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Asset, ids[i])
		m.removed_Asset[ids[i]] = struct{}{}
	}
}

// RemovedAsset returns the removed IDs of the "Asset" edge to the Asset entity.
func (m *AssetGroupMutation) RemovedAssetIDs() (ids []int) {
	for id := range m.removed_Asset {
		ids = append(ids, id)
	}
	return
}

// AssetIDs returns the "Asset" edge IDs in the mutation.
func (m *AssetGroupMutation) AssetIDs() (ids []int) {
	for id := range m._Asset {
		ids = append(ids, id)
	}
	return
}

// ResetAsset resets all changes to the "Asset" edge.
func (m *AssetGroupMutation) ResetAsset() {
	m._Asset = nil
	m.cleared_Asset = false
	m.removed_Asset = nil
}

// Where appends a list predicates to the AssetGroupMutation builder.
func (m *AssetGroupMutation) Where(ps ...predicate.AssetGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssetGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssetGroup).
func (m *AssetGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetGroupMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, assetgroup.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetgroup.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetgroup.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown AssetGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown AssetGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AssetGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetGroupMutation) ResetField(name string) error {
	switch name {
	case assetgroup.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown AssetGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Asset != nil {
		edges = append(edges, assetgroup.EdgeAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assetgroup.EdgeAsset:
		ids := make([]ent.Value, 0, len(m._Asset))
		for id := range m._Asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Asset != nil {
		edges = append(edges, assetgroup.EdgeAsset)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assetgroup.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.removed_Asset))
		for id := range m.removed_Asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Asset {
		edges = append(edges, assetgroup.EdgeAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case assetgroup.EdgeAsset:
		return m.cleared_Asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetGroupMutation) ResetEdge(name string) error {
	switch name {
	case assetgroup.EdgeAsset:
		m.ResetAsset()
		return nil
	}
	return fmt.Errorf("unknown AssetGroup edge %s", name)
}

// AssetPhotoMutation represents an operation that mutates the AssetPhoto nodes in the graph.
type AssetPhotoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_AssetPhoto   *string
	clearedFields map[string]struct{}
	_Asset        *int
	cleared_Asset bool
	done          bool
	oldValue      func(context.Context) (*AssetPhoto, error)
	predicates    []predicate.AssetPhoto
}

var _ ent.Mutation = (*AssetPhotoMutation)(nil)

// assetphotoOption allows management of the mutation configuration using functional options.
type assetphotoOption func(*AssetPhotoMutation)

// newAssetPhotoMutation creates new mutation for the AssetPhoto entity.
func newAssetPhotoMutation(c config, op Op, opts ...assetphotoOption) *AssetPhotoMutation {
	m := &AssetPhotoMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetPhoto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetPhotoID sets the ID field of the mutation.
func withAssetPhotoID(id int) assetphotoOption {
	return func(m *AssetPhotoMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetPhoto
		)
		m.oldValue = func(ctx context.Context) (*AssetPhoto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetPhoto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetPhoto sets the old AssetPhoto of the mutation.
func withAssetPhoto(node *AssetPhoto) assetphotoOption {
	return func(m *AssetPhotoMutation) {
		m.oldValue = func(context.Context) (*AssetPhoto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetPhotoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetPhotoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssetPhoto entities.
func (m *AssetPhotoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetPhotoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetPhotoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetPhoto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAssetPhoto sets the "AssetPhoto" field.
func (m *AssetPhotoMutation) SetAssetPhoto(s string) {
	m._AssetPhoto = &s
}

// AssetPhoto returns the value of the "AssetPhoto" field in the mutation.
func (m *AssetPhotoMutation) AssetPhoto() (r string, exists bool) {
	v := m._AssetPhoto
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetPhoto returns the old "AssetPhoto" field's value of the AssetPhoto entity.
// If the AssetPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetPhotoMutation) OldAssetPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetPhoto: %w", err)
	}
	return oldValue.AssetPhoto, nil
}

// ResetAssetPhoto resets all changes to the "AssetPhoto" field.
func (m *AssetPhotoMutation) ResetAssetPhoto() {
	m._AssetPhoto = nil
}

// SetAssetID sets the "Asset" edge to the Asset entity by id.
func (m *AssetPhotoMutation) SetAssetID(id int) {
	m._Asset = &id
}

// ClearAsset clears the "Asset" edge to the Asset entity.
func (m *AssetPhotoMutation) ClearAsset() {
	m.cleared_Asset = true
}

// AssetCleared reports if the "Asset" edge to the Asset entity was cleared.
func (m *AssetPhotoMutation) AssetCleared() bool {
	return m.cleared_Asset
}

// AssetID returns the "Asset" edge ID in the mutation.
func (m *AssetPhotoMutation) AssetID() (id int, exists bool) {
	if m._Asset != nil {
		return *m._Asset, true
	}
	return
}

// AssetIDs returns the "Asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *AssetPhotoMutation) AssetIDs() (ids []int) {
	if id := m._Asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "Asset" edge.
func (m *AssetPhotoMutation) ResetAsset() {
	m._Asset = nil
	m.cleared_Asset = false
}

// Where appends a list predicates to the AssetPhotoMutation builder.
func (m *AssetPhotoMutation) Where(ps ...predicate.AssetPhoto) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetPhotoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetPhotoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssetPhoto, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetPhotoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetPhotoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssetPhoto).
func (m *AssetPhotoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetPhotoMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._AssetPhoto != nil {
		fields = append(fields, assetphoto.FieldAssetPhoto)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetPhotoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetphoto.FieldAssetPhoto:
		return m.AssetPhoto()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetPhotoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetphoto.FieldAssetPhoto:
		return m.OldAssetPhoto(ctx)
	}
	return nil, fmt.Errorf("unknown AssetPhoto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetPhotoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetphoto.FieldAssetPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetPhoto(v)
		return nil
	}
	return fmt.Errorf("unknown AssetPhoto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetPhotoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetPhotoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetPhotoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetPhoto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetPhotoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetPhotoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetPhotoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AssetPhoto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetPhotoMutation) ResetField(name string) error {
	switch name {
	case assetphoto.FieldAssetPhoto:
		m.ResetAssetPhoto()
		return nil
	}
	return fmt.Errorf("unknown AssetPhoto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetPhotoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Asset != nil {
		edges = append(edges, assetphoto.EdgeAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetPhotoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assetphoto.EdgeAsset:
		if id := m._Asset; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetPhotoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetPhotoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetPhotoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Asset {
		edges = append(edges, assetphoto.EdgeAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetPhotoMutation) EdgeCleared(name string) bool {
	switch name {
	case assetphoto.EdgeAsset:
		return m.cleared_Asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetPhotoMutation) ClearEdge(name string) error {
	switch name {
	case assetphoto.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown AssetPhoto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetPhotoMutation) ResetEdge(name string) error {
	switch name {
	case assetphoto.EdgeAsset:
		m.ResetAsset()
		return nil
	}
	return fmt.Errorf("unknown AssetPhoto edge %s", name)
}

// AssetTransferLogMutation represents an operation that mutates the AssetTransferLog nodes in the graph.
type AssetTransferLogMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	_FromAssetSN                   *int
	add_FromAssetSN                *int
	_ToAssetSN                     *int
	add_ToAssetSN                  *int
	_TransferDate                  *time.Time
	clearedFields                  map[string]struct{}
	_Asset                         *int
	cleared_Asset                  bool
	_FromDepartmentLocation        *int
	cleared_FromDepartmentLocation bool
	_ToDepartmentLocation          *int
	cleared_ToDepartmentLocation   bool
	done                           bool
	oldValue                       func(context.Context) (*AssetTransferLog, error)
	predicates                     []predicate.AssetTransferLog
}

var _ ent.Mutation = (*AssetTransferLogMutation)(nil)

// assettransferlogOption allows management of the mutation configuration using functional options.
type assettransferlogOption func(*AssetTransferLogMutation)

// newAssetTransferLogMutation creates new mutation for the AssetTransferLog entity.
func newAssetTransferLogMutation(c config, op Op, opts ...assettransferlogOption) *AssetTransferLogMutation {
	m := &AssetTransferLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetTransferLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetTransferLogID sets the ID field of the mutation.
func withAssetTransferLogID(id int) assettransferlogOption {
	return func(m *AssetTransferLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetTransferLog
		)
		m.oldValue = func(ctx context.Context) (*AssetTransferLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetTransferLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetTransferLog sets the old AssetTransferLog of the mutation.
func withAssetTransferLog(node *AssetTransferLog) assettransferlogOption {
	return func(m *AssetTransferLogMutation) {
		m.oldValue = func(context.Context) (*AssetTransferLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetTransferLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetTransferLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssetTransferLog entities.
func (m *AssetTransferLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetTransferLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetTransferLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetTransferLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAssetID sets the "AssetID" field.
func (m *AssetTransferLogMutation) SetAssetID(i int) {
	m._Asset = &i
}

// AssetID returns the value of the "AssetID" field in the mutation.
func (m *AssetTransferLogMutation) AssetID() (r int, exists bool) {
	v := m._Asset
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetID returns the old "AssetID" field's value of the AssetTransferLog entity.
// If the AssetTransferLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTransferLogMutation) OldAssetID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetID: %w", err)
	}
	return oldValue.AssetID, nil
}

// ResetAssetID resets all changes to the "AssetID" field.
func (m *AssetTransferLogMutation) ResetAssetID() {
	m._Asset = nil
}

// SetFromAssetSN sets the "FromAssetSN" field.
func (m *AssetTransferLogMutation) SetFromAssetSN(i int) {
	m._FromAssetSN = &i
	m.add_FromAssetSN = nil
}

// FromAssetSN returns the value of the "FromAssetSN" field in the mutation.
func (m *AssetTransferLogMutation) FromAssetSN() (r int, exists bool) {
	v := m._FromAssetSN
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAssetSN returns the old "FromAssetSN" field's value of the AssetTransferLog entity.
// If the AssetTransferLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTransferLogMutation) OldFromAssetSN(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAssetSN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAssetSN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAssetSN: %w", err)
	}
	return oldValue.FromAssetSN, nil
}

// AddFromAssetSN adds i to the "FromAssetSN" field.
func (m *AssetTransferLogMutation) AddFromAssetSN(i int) {
	if m.add_FromAssetSN != nil {
		*m.add_FromAssetSN += i
	} else {
		m.add_FromAssetSN = &i
	}
}

// AddedFromAssetSN returns the value that was added to the "FromAssetSN" field in this mutation.
func (m *AssetTransferLogMutation) AddedFromAssetSN() (r int, exists bool) {
	v := m.add_FromAssetSN
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromAssetSN resets all changes to the "FromAssetSN" field.
func (m *AssetTransferLogMutation) ResetFromAssetSN() {
	m._FromAssetSN = nil
	m.add_FromAssetSN = nil
}

// SetToAssetSN sets the "ToAssetSN" field.
func (m *AssetTransferLogMutation) SetToAssetSN(i int) {
	m._ToAssetSN = &i
	m.add_ToAssetSN = nil
}

// ToAssetSN returns the value of the "ToAssetSN" field in the mutation.
func (m *AssetTransferLogMutation) ToAssetSN() (r int, exists bool) {
	v := m._ToAssetSN
	if v == nil {
		return
	}
	return *v, true
}

// OldToAssetSN returns the old "ToAssetSN" field's value of the AssetTransferLog entity.
// If the AssetTransferLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTransferLogMutation) OldToAssetSN(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAssetSN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAssetSN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAssetSN: %w", err)
	}
	return oldValue.ToAssetSN, nil
}

// AddToAssetSN adds i to the "ToAssetSN" field.
func (m *AssetTransferLogMutation) AddToAssetSN(i int) {
	if m.add_ToAssetSN != nil {
		*m.add_ToAssetSN += i
	} else {
		m.add_ToAssetSN = &i
	}
}

// AddedToAssetSN returns the value that was added to the "ToAssetSN" field in this mutation.
func (m *AssetTransferLogMutation) AddedToAssetSN() (r int, exists bool) {
	v := m.add_ToAssetSN
	if v == nil {
		return
	}
	return *v, true
}

// ResetToAssetSN resets all changes to the "ToAssetSN" field.
func (m *AssetTransferLogMutation) ResetToAssetSN() {
	m._ToAssetSN = nil
	m.add_ToAssetSN = nil
}

// SetFromDepartmentLocationID sets the "FromDepartmentLocationID" field.
func (m *AssetTransferLogMutation) SetFromDepartmentLocationID(i int) {
	m._FromDepartmentLocation = &i
}

// FromDepartmentLocationID returns the value of the "FromDepartmentLocationID" field in the mutation.
func (m *AssetTransferLogMutation) FromDepartmentLocationID() (r int, exists bool) {
	v := m._FromDepartmentLocation
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDepartmentLocationID returns the old "FromDepartmentLocationID" field's value of the AssetTransferLog entity.
// If the AssetTransferLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTransferLogMutation) OldFromDepartmentLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDepartmentLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDepartmentLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDepartmentLocationID: %w", err)
	}
	return oldValue.FromDepartmentLocationID, nil
}

// ResetFromDepartmentLocationID resets all changes to the "FromDepartmentLocationID" field.
func (m *AssetTransferLogMutation) ResetFromDepartmentLocationID() {
	m._FromDepartmentLocation = nil
}

// SetToDepartmentLocationID sets the "ToDepartmentLocationID" field.
func (m *AssetTransferLogMutation) SetToDepartmentLocationID(i int) {
	m._ToDepartmentLocation = &i
}

// ToDepartmentLocationID returns the value of the "ToDepartmentLocationID" field in the mutation.
func (m *AssetTransferLogMutation) ToDepartmentLocationID() (r int, exists bool) {
	v := m._ToDepartmentLocation
	if v == nil {
		return
	}
	return *v, true
}

// OldToDepartmentLocationID returns the old "ToDepartmentLocationID" field's value of the AssetTransferLog entity.
// If the AssetTransferLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTransferLogMutation) OldToDepartmentLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDepartmentLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDepartmentLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDepartmentLocationID: %w", err)
	}
	return oldValue.ToDepartmentLocationID, nil
}

// ResetToDepartmentLocationID resets all changes to the "ToDepartmentLocationID" field.
func (m *AssetTransferLogMutation) ResetToDepartmentLocationID() {
	m._ToDepartmentLocation = nil
}

// SetTransferDate sets the "TransferDate" field.
func (m *AssetTransferLogMutation) SetTransferDate(t time.Time) {
	m._TransferDate = &t
}

// TransferDate returns the value of the "TransferDate" field in the mutation.
func (m *AssetTransferLogMutation) TransferDate() (r time.Time, exists bool) {
	v := m._TransferDate
	if v == nil {
		return
	}
	return *v, true
}

// OldTransferDate returns the old "TransferDate" field's value of the AssetTransferLog entity.
// If the AssetTransferLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetTransferLogMutation) OldTransferDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransferDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransferDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransferDate: %w", err)
	}
	return oldValue.TransferDate, nil
}

// ResetTransferDate resets all changes to the "TransferDate" field.
func (m *AssetTransferLogMutation) ResetTransferDate() {
	m._TransferDate = nil
}

// ClearAsset clears the "Asset" edge to the Asset entity.
func (m *AssetTransferLogMutation) ClearAsset() {
	m.cleared_Asset = true
}

// AssetCleared reports if the "Asset" edge to the Asset entity was cleared.
func (m *AssetTransferLogMutation) AssetCleared() bool {
	return m.cleared_Asset
}

// AssetIDs returns the "Asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *AssetTransferLogMutation) AssetIDs() (ids []int) {
	if id := m._Asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "Asset" edge.
func (m *AssetTransferLogMutation) ResetAsset() {
	m._Asset = nil
	m.cleared_Asset = false
}

// ClearFromDepartmentLocation clears the "FromDepartmentLocation" edge to the DepartmentLocation entity.
func (m *AssetTransferLogMutation) ClearFromDepartmentLocation() {
	m.cleared_FromDepartmentLocation = true
}

// FromDepartmentLocationCleared reports if the "FromDepartmentLocation" edge to the DepartmentLocation entity was cleared.
func (m *AssetTransferLogMutation) FromDepartmentLocationCleared() bool {
	return m.cleared_FromDepartmentLocation
}

// FromDepartmentLocationIDs returns the "FromDepartmentLocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromDepartmentLocationID instead. It exists only for internal usage by the builders.
func (m *AssetTransferLogMutation) FromDepartmentLocationIDs() (ids []int) {
	if id := m._FromDepartmentLocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromDepartmentLocation resets all changes to the "FromDepartmentLocation" edge.
func (m *AssetTransferLogMutation) ResetFromDepartmentLocation() {
	m._FromDepartmentLocation = nil
	m.cleared_FromDepartmentLocation = false
}

// ClearToDepartmentLocation clears the "ToDepartmentLocation" edge to the DepartmentLocation entity.
func (m *AssetTransferLogMutation) ClearToDepartmentLocation() {
	m.cleared_ToDepartmentLocation = true
}

// ToDepartmentLocationCleared reports if the "ToDepartmentLocation" edge to the DepartmentLocation entity was cleared.
func (m *AssetTransferLogMutation) ToDepartmentLocationCleared() bool {
	return m.cleared_ToDepartmentLocation
}

// ToDepartmentLocationIDs returns the "ToDepartmentLocation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToDepartmentLocationID instead. It exists only for internal usage by the builders.
func (m *AssetTransferLogMutation) ToDepartmentLocationIDs() (ids []int) {
	if id := m._ToDepartmentLocation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToDepartmentLocation resets all changes to the "ToDepartmentLocation" edge.
func (m *AssetTransferLogMutation) ResetToDepartmentLocation() {
	m._ToDepartmentLocation = nil
	m.cleared_ToDepartmentLocation = false
}

// Where appends a list predicates to the AssetTransferLogMutation builder.
func (m *AssetTransferLogMutation) Where(ps ...predicate.AssetTransferLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssetTransferLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssetTransferLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssetTransferLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssetTransferLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssetTransferLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssetTransferLog).
func (m *AssetTransferLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetTransferLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Asset != nil {
		fields = append(fields, assettransferlog.FieldAssetID)
	}
	if m._FromAssetSN != nil {
		fields = append(fields, assettransferlog.FieldFromAssetSN)
	}
	if m._ToAssetSN != nil {
		fields = append(fields, assettransferlog.FieldToAssetSN)
	}
	if m._FromDepartmentLocation != nil {
		fields = append(fields, assettransferlog.FieldFromDepartmentLocationID)
	}
	if m._ToDepartmentLocation != nil {
		fields = append(fields, assettransferlog.FieldToDepartmentLocationID)
	}
	if m._TransferDate != nil {
		fields = append(fields, assettransferlog.FieldTransferDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetTransferLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assettransferlog.FieldAssetID:
		return m.AssetID()
	case assettransferlog.FieldFromAssetSN:
		return m.FromAssetSN()
	case assettransferlog.FieldToAssetSN:
		return m.ToAssetSN()
	case assettransferlog.FieldFromDepartmentLocationID:
		return m.FromDepartmentLocationID()
	case assettransferlog.FieldToDepartmentLocationID:
		return m.ToDepartmentLocationID()
	case assettransferlog.FieldTransferDate:
		return m.TransferDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetTransferLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assettransferlog.FieldAssetID:
		return m.OldAssetID(ctx)
	case assettransferlog.FieldFromAssetSN:
		return m.OldFromAssetSN(ctx)
	case assettransferlog.FieldToAssetSN:
		return m.OldToAssetSN(ctx)
	case assettransferlog.FieldFromDepartmentLocationID:
		return m.OldFromDepartmentLocationID(ctx)
	case assettransferlog.FieldToDepartmentLocationID:
		return m.OldToDepartmentLocationID(ctx)
	case assettransferlog.FieldTransferDate:
		return m.OldTransferDate(ctx)
	}
	return nil, fmt.Errorf("unknown AssetTransferLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetTransferLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assettransferlog.FieldAssetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetID(v)
		return nil
	case assettransferlog.FieldFromAssetSN:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAssetSN(v)
		return nil
	case assettransferlog.FieldToAssetSN:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAssetSN(v)
		return nil
	case assettransferlog.FieldFromDepartmentLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDepartmentLocationID(v)
		return nil
	case assettransferlog.FieldToDepartmentLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDepartmentLocationID(v)
		return nil
	case assettransferlog.FieldTransferDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransferDate(v)
		return nil
	}
	return fmt.Errorf("unknown AssetTransferLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetTransferLogMutation) AddedFields() []string {
	var fields []string
	if m.add_FromAssetSN != nil {
		fields = append(fields, assettransferlog.FieldFromAssetSN)
	}
	if m.add_ToAssetSN != nil {
		fields = append(fields, assettransferlog.FieldToAssetSN)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetTransferLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assettransferlog.FieldFromAssetSN:
		return m.AddedFromAssetSN()
	case assettransferlog.FieldToAssetSN:
		return m.AddedToAssetSN()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetTransferLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assettransferlog.FieldFromAssetSN:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromAssetSN(v)
		return nil
	case assettransferlog.FieldToAssetSN:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToAssetSN(v)
		return nil
	}
	return fmt.Errorf("unknown AssetTransferLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetTransferLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetTransferLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetTransferLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AssetTransferLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetTransferLogMutation) ResetField(name string) error {
	switch name {
	case assettransferlog.FieldAssetID:
		m.ResetAssetID()
		return nil
	case assettransferlog.FieldFromAssetSN:
		m.ResetFromAssetSN()
		return nil
	case assettransferlog.FieldToAssetSN:
		m.ResetToAssetSN()
		return nil
	case assettransferlog.FieldFromDepartmentLocationID:
		m.ResetFromDepartmentLocationID()
		return nil
	case assettransferlog.FieldToDepartmentLocationID:
		m.ResetToDepartmentLocationID()
		return nil
	case assettransferlog.FieldTransferDate:
		m.ResetTransferDate()
		return nil
	}
	return fmt.Errorf("unknown AssetTransferLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetTransferLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Asset != nil {
		edges = append(edges, assettransferlog.EdgeAsset)
	}
	if m._FromDepartmentLocation != nil {
		edges = append(edges, assettransferlog.EdgeFromDepartmentLocation)
	}
	if m._ToDepartmentLocation != nil {
		edges = append(edges, assettransferlog.EdgeToDepartmentLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetTransferLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assettransferlog.EdgeAsset:
		if id := m._Asset; id != nil {
			return []ent.Value{*id}
		}
	case assettransferlog.EdgeFromDepartmentLocation:
		if id := m._FromDepartmentLocation; id != nil {
			return []ent.Value{*id}
		}
	case assettransferlog.EdgeToDepartmentLocation:
		if id := m._ToDepartmentLocation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetTransferLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetTransferLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetTransferLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Asset {
		edges = append(edges, assettransferlog.EdgeAsset)
	}
	if m.cleared_FromDepartmentLocation {
		edges = append(edges, assettransferlog.EdgeFromDepartmentLocation)
	}
	if m.cleared_ToDepartmentLocation {
		edges = append(edges, assettransferlog.EdgeToDepartmentLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetTransferLogMutation) EdgeCleared(name string) bool {
	switch name {
	case assettransferlog.EdgeAsset:
		return m.cleared_Asset
	case assettransferlog.EdgeFromDepartmentLocation:
		return m.cleared_FromDepartmentLocation
	case assettransferlog.EdgeToDepartmentLocation:
		return m.cleared_ToDepartmentLocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetTransferLogMutation) ClearEdge(name string) error {
	switch name {
	case assettransferlog.EdgeAsset:
		m.ClearAsset()
		return nil
	case assettransferlog.EdgeFromDepartmentLocation:
		m.ClearFromDepartmentLocation()
		return nil
	case assettransferlog.EdgeToDepartmentLocation:
		m.ClearToDepartmentLocation()
		return nil
	}
	return fmt.Errorf("unknown AssetTransferLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetTransferLogMutation) ResetEdge(name string) error {
	switch name {
	case assettransferlog.EdgeAsset:
		m.ResetAsset()
		return nil
	case assettransferlog.EdgeFromDepartmentLocation:
		m.ResetFromDepartmentLocation()
		return nil
	case assettransferlog.EdgeToDepartmentLocation:
		m.ResetToDepartmentLocation()
		return nil
	}
	return fmt.Errorf("unknown AssetTransferLog edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Name                      *string
	clearedFields              map[string]struct{}
	_DepartmentLocation        map[int]struct{}
	removed_DepartmentLocation map[int]struct{}
	cleared_DepartmentLocation bool
	done                       bool
	oldValue                   func(context.Context) (*Department, error)
	predicates                 []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *DepartmentMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *DepartmentMutation) ResetName() {
	m._Name = nil
}

// AddDepartmentLocationIDs adds the "DepartmentLocation" edge to the DepartmentLocation entity by ids.
func (m *DepartmentMutation) AddDepartmentLocationIDs(ids ...int) {
	if m._DepartmentLocation == nil {
		m._DepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		m._DepartmentLocation[ids[i]] = struct{}{}
	}
}

// ClearDepartmentLocation clears the "DepartmentLocation" edge to the DepartmentLocation entity.
func (m *DepartmentMutation) ClearDepartmentLocation() {
	m.cleared_DepartmentLocation = true
}

// DepartmentLocationCleared reports if the "DepartmentLocation" edge to the DepartmentLocation entity was cleared.
func (m *DepartmentMutation) DepartmentLocationCleared() bool {
	return m.cleared_DepartmentLocation
}

// RemoveDepartmentLocationIDs removes the "DepartmentLocation" edge to the DepartmentLocation entity by IDs.
func (m *DepartmentMutation) RemoveDepartmentLocationIDs(ids ...int) {
	if m.removed_DepartmentLocation == nil {
		m.removed_DepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._DepartmentLocation, ids[i])
		m.removed_DepartmentLocation[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentLocation returns the removed IDs of the "DepartmentLocation" edge to the DepartmentLocation entity.
func (m *DepartmentMutation) RemovedDepartmentLocationIDs() (ids []int) {
	for id := range m.removed_DepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// DepartmentLocationIDs returns the "DepartmentLocation" edge IDs in the mutation.
func (m *DepartmentMutation) DepartmentLocationIDs() (ids []int) {
	for id := range m._DepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentLocation resets all changes to the "DepartmentLocation" edge.
func (m *DepartmentMutation) ResetDepartmentLocation() {
	m._DepartmentLocation = nil
	m.cleared_DepartmentLocation = false
	m.removed_DepartmentLocation = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, department.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._DepartmentLocation != nil {
		edges = append(edges, department.EdgeDepartmentLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentLocation:
		ids := make([]ent.Value, 0, len(m._DepartmentLocation))
		for id := range m._DepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_DepartmentLocation != nil {
		edges = append(edges, department.EdgeDepartmentLocation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentLocation:
		ids := make([]ent.Value, 0, len(m.removed_DepartmentLocation))
		for id := range m.removed_DepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_DepartmentLocation {
		edges = append(edges, department.EdgeDepartmentLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeDepartmentLocation:
		return m.cleared_DepartmentLocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeDepartmentLocation:
		m.ResetDepartmentLocation()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DepartmentLocationMutation represents an operation that mutates the DepartmentLocation nodes in the graph.
type DepartmentLocationMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	_EndDate                       *time.Time
	_StartDate                     *time.Time
	clearedFields                  map[string]struct{}
	_Asset                         map[int]struct{}
	removed_Asset                  map[int]struct{}
	cleared_Asset                  bool
	_FromDepartmentLocation        map[int]struct{}
	removed_FromDepartmentLocation map[int]struct{}
	cleared_FromDepartmentLocation bool
	_ToDepartmentLocation          map[int]struct{}
	removed_ToDepartmentLocation   map[int]struct{}
	cleared_ToDepartmentLocation   bool
	_Department                    *int
	cleared_Department             bool
	_Location                      *int
	cleared_Location               bool
	done                           bool
	oldValue                       func(context.Context) (*DepartmentLocation, error)
	predicates                     []predicate.DepartmentLocation
}

var _ ent.Mutation = (*DepartmentLocationMutation)(nil)

// departmentlocationOption allows management of the mutation configuration using functional options.
type departmentlocationOption func(*DepartmentLocationMutation)

// newDepartmentLocationMutation creates new mutation for the DepartmentLocation entity.
func newDepartmentLocationMutation(c config, op Op, opts ...departmentlocationOption) *DepartmentLocationMutation {
	m := &DepartmentLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartmentLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentLocationID sets the ID field of the mutation.
func withDepartmentLocationID(id int) departmentlocationOption {
	return func(m *DepartmentLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *DepartmentLocation
		)
		m.oldValue = func(ctx context.Context) (*DepartmentLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DepartmentLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartmentLocation sets the old DepartmentLocation of the mutation.
func withDepartmentLocation(node *DepartmentLocation) departmentlocationOption {
	return func(m *DepartmentLocationMutation) {
		m.oldValue = func(context.Context) (*DepartmentLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DepartmentLocation entities.
func (m *DepartmentLocationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DepartmentLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDepartmentID sets the "DepartmentID" field.
func (m *DepartmentLocationMutation) SetDepartmentID(i int) {
	m._Department = &i
}

// DepartmentID returns the value of the "DepartmentID" field in the mutation.
func (m *DepartmentLocationMutation) DepartmentID() (r int, exists bool) {
	v := m._Department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "DepartmentID" field's value of the DepartmentLocation entity.
// If the DepartmentLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentLocationMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "DepartmentID" field.
func (m *DepartmentLocationMutation) ResetDepartmentID() {
	m._Department = nil
}

// SetLocationID sets the "LocationID" field.
func (m *DepartmentLocationMutation) SetLocationID(i int) {
	m._Location = &i
}

// LocationID returns the value of the "LocationID" field in the mutation.
func (m *DepartmentLocationMutation) LocationID() (r int, exists bool) {
	v := m._Location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "LocationID" field's value of the DepartmentLocation entity.
// If the DepartmentLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentLocationMutation) OldLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ResetLocationID resets all changes to the "LocationID" field.
func (m *DepartmentLocationMutation) ResetLocationID() {
	m._Location = nil
}

// SetEndDate sets the "EndDate" field.
func (m *DepartmentLocationMutation) SetEndDate(t time.Time) {
	m._EndDate = &t
}

// EndDate returns the value of the "EndDate" field in the mutation.
func (m *DepartmentLocationMutation) EndDate() (r time.Time, exists bool) {
	v := m._EndDate
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "EndDate" field's value of the DepartmentLocation entity.
// If the DepartmentLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentLocationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "EndDate" field.
func (m *DepartmentLocationMutation) ResetEndDate() {
	m._EndDate = nil
}

// SetStartDate sets the "StartDate" field.
func (m *DepartmentLocationMutation) SetStartDate(t time.Time) {
	m._StartDate = &t
}

// StartDate returns the value of the "StartDate" field in the mutation.
func (m *DepartmentLocationMutation) StartDate() (r time.Time, exists bool) {
	v := m._StartDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "StartDate" field's value of the DepartmentLocation entity.
// If the DepartmentLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentLocationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "StartDate" field.
func (m *DepartmentLocationMutation) ResetStartDate() {
	m._StartDate = nil
}

// AddAssetIDs adds the "Asset" edge to the Asset entity by ids.
func (m *DepartmentLocationMutation) AddAssetIDs(ids ...int) {
	if m._Asset == nil {
		m._Asset = make(map[int]struct{})
	}
	for i := range ids {
		m._Asset[ids[i]] = struct{}{}
	}
}

// ClearAsset clears the "Asset" edge to the Asset entity.
func (m *DepartmentLocationMutation) ClearAsset() {
	m.cleared_Asset = true
}

// AssetCleared reports if the "Asset" edge to the Asset entity was cleared.
func (m *DepartmentLocationMutation) AssetCleared() bool {
	return m.cleared_Asset
}

// RemoveAssetIDs removes the "Asset" edge to the Asset entity by IDs.
func (m *DepartmentLocationMutation) RemoveAssetIDs(ids ...int) {
	if m.removed_Asset == nil {
		m.removed_Asset = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Asset, ids[i])
		m.removed_Asset[ids[i]] = struct{}{}
	}
}

// RemovedAsset returns the removed IDs of the "Asset" edge to the Asset entity.
func (m *DepartmentLocationMutation) RemovedAssetIDs() (ids []int) {
	for id := range m.removed_Asset {
		ids = append(ids, id)
	}
	return
}

// AssetIDs returns the "Asset" edge IDs in the mutation.
func (m *DepartmentLocationMutation) AssetIDs() (ids []int) {
	for id := range m._Asset {
		ids = append(ids, id)
	}
	return
}

// ResetAsset resets all changes to the "Asset" edge.
func (m *DepartmentLocationMutation) ResetAsset() {
	m._Asset = nil
	m.cleared_Asset = false
	m.removed_Asset = nil
}

// AddFromDepartmentLocationIDs adds the "FromDepartmentLocation" edge to the AssetTransferLog entity by ids.
func (m *DepartmentLocationMutation) AddFromDepartmentLocationIDs(ids ...int) {
	if m._FromDepartmentLocation == nil {
		m._FromDepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		m._FromDepartmentLocation[ids[i]] = struct{}{}
	}
}

// ClearFromDepartmentLocation clears the "FromDepartmentLocation" edge to the AssetTransferLog entity.
func (m *DepartmentLocationMutation) ClearFromDepartmentLocation() {
	m.cleared_FromDepartmentLocation = true
}

// FromDepartmentLocationCleared reports if the "FromDepartmentLocation" edge to the AssetTransferLog entity was cleared.
func (m *DepartmentLocationMutation) FromDepartmentLocationCleared() bool {
	return m.cleared_FromDepartmentLocation
}

// RemoveFromDepartmentLocationIDs removes the "FromDepartmentLocation" edge to the AssetTransferLog entity by IDs.
func (m *DepartmentLocationMutation) RemoveFromDepartmentLocationIDs(ids ...int) {
	if m.removed_FromDepartmentLocation == nil {
		m.removed_FromDepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._FromDepartmentLocation, ids[i])
		m.removed_FromDepartmentLocation[ids[i]] = struct{}{}
	}
}

// RemovedFromDepartmentLocation returns the removed IDs of the "FromDepartmentLocation" edge to the AssetTransferLog entity.
func (m *DepartmentLocationMutation) RemovedFromDepartmentLocationIDs() (ids []int) {
	for id := range m.removed_FromDepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// FromDepartmentLocationIDs returns the "FromDepartmentLocation" edge IDs in the mutation.
func (m *DepartmentLocationMutation) FromDepartmentLocationIDs() (ids []int) {
	for id := range m._FromDepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// ResetFromDepartmentLocation resets all changes to the "FromDepartmentLocation" edge.
func (m *DepartmentLocationMutation) ResetFromDepartmentLocation() {
	m._FromDepartmentLocation = nil
	m.cleared_FromDepartmentLocation = false
	m.removed_FromDepartmentLocation = nil
}

// AddToDepartmentLocationIDs adds the "ToDepartmentLocation" edge to the AssetTransferLog entity by ids.
func (m *DepartmentLocationMutation) AddToDepartmentLocationIDs(ids ...int) {
	if m._ToDepartmentLocation == nil {
		m._ToDepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		m._ToDepartmentLocation[ids[i]] = struct{}{}
	}
}

// ClearToDepartmentLocation clears the "ToDepartmentLocation" edge to the AssetTransferLog entity.
func (m *DepartmentLocationMutation) ClearToDepartmentLocation() {
	m.cleared_ToDepartmentLocation = true
}

// ToDepartmentLocationCleared reports if the "ToDepartmentLocation" edge to the AssetTransferLog entity was cleared.
func (m *DepartmentLocationMutation) ToDepartmentLocationCleared() bool {
	return m.cleared_ToDepartmentLocation
}

// RemoveToDepartmentLocationIDs removes the "ToDepartmentLocation" edge to the AssetTransferLog entity by IDs.
func (m *DepartmentLocationMutation) RemoveToDepartmentLocationIDs(ids ...int) {
	if m.removed_ToDepartmentLocation == nil {
		m.removed_ToDepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._ToDepartmentLocation, ids[i])
		m.removed_ToDepartmentLocation[ids[i]] = struct{}{}
	}
}

// RemovedToDepartmentLocation returns the removed IDs of the "ToDepartmentLocation" edge to the AssetTransferLog entity.
func (m *DepartmentLocationMutation) RemovedToDepartmentLocationIDs() (ids []int) {
	for id := range m.removed_ToDepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// ToDepartmentLocationIDs returns the "ToDepartmentLocation" edge IDs in the mutation.
func (m *DepartmentLocationMutation) ToDepartmentLocationIDs() (ids []int) {
	for id := range m._ToDepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// ResetToDepartmentLocation resets all changes to the "ToDepartmentLocation" edge.
func (m *DepartmentLocationMutation) ResetToDepartmentLocation() {
	m._ToDepartmentLocation = nil
	m.cleared_ToDepartmentLocation = false
	m.removed_ToDepartmentLocation = nil
}

// ClearDepartment clears the "Department" edge to the Department entity.
func (m *DepartmentLocationMutation) ClearDepartment() {
	m.cleared_Department = true
}

// DepartmentCleared reports if the "Department" edge to the Department entity was cleared.
func (m *DepartmentLocationMutation) DepartmentCleared() bool {
	return m.cleared_Department
}

// DepartmentIDs returns the "Department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *DepartmentLocationMutation) DepartmentIDs() (ids []int) {
	if id := m._Department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "Department" edge.
func (m *DepartmentLocationMutation) ResetDepartment() {
	m._Department = nil
	m.cleared_Department = false
}

// ClearLocation clears the "Location" edge to the Location entity.
func (m *DepartmentLocationMutation) ClearLocation() {
	m.cleared_Location = true
}

// LocationCleared reports if the "Location" edge to the Location entity was cleared.
func (m *DepartmentLocationMutation) LocationCleared() bool {
	return m.cleared_Location
}

// LocationIDs returns the "Location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *DepartmentLocationMutation) LocationIDs() (ids []int) {
	if id := m._Location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "Location" edge.
func (m *DepartmentLocationMutation) ResetLocation() {
	m._Location = nil
	m.cleared_Location = false
}

// Where appends a list predicates to the DepartmentLocationMutation builder.
func (m *DepartmentLocationMutation) Where(ps ...predicate.DepartmentLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DepartmentLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DepartmentLocation).
func (m *DepartmentLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentLocationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Department != nil {
		fields = append(fields, departmentlocation.FieldDepartmentID)
	}
	if m._Location != nil {
		fields = append(fields, departmentlocation.FieldLocationID)
	}
	if m._EndDate != nil {
		fields = append(fields, departmentlocation.FieldEndDate)
	}
	if m._StartDate != nil {
		fields = append(fields, departmentlocation.FieldStartDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case departmentlocation.FieldDepartmentID:
		return m.DepartmentID()
	case departmentlocation.FieldLocationID:
		return m.LocationID()
	case departmentlocation.FieldEndDate:
		return m.EndDate()
	case departmentlocation.FieldStartDate:
		return m.StartDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case departmentlocation.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case departmentlocation.FieldLocationID:
		return m.OldLocationID(ctx)
	case departmentlocation.FieldEndDate:
		return m.OldEndDate(ctx)
	case departmentlocation.FieldStartDate:
		return m.OldStartDate(ctx)
	}
	return nil, fmt.Errorf("unknown DepartmentLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case departmentlocation.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case departmentlocation.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case departmentlocation.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case departmentlocation.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	}
	return fmt.Errorf("unknown DepartmentLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentLocationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DepartmentLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentLocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentLocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DepartmentLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentLocationMutation) ResetField(name string) error {
	switch name {
	case departmentlocation.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case departmentlocation.FieldLocationID:
		m.ResetLocationID()
		return nil
	case departmentlocation.FieldEndDate:
		m.ResetEndDate()
		return nil
	case departmentlocation.FieldStartDate:
		m.ResetStartDate()
		return nil
	}
	return fmt.Errorf("unknown DepartmentLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._Asset != nil {
		edges = append(edges, departmentlocation.EdgeAsset)
	}
	if m._FromDepartmentLocation != nil {
		edges = append(edges, departmentlocation.EdgeFromDepartmentLocation)
	}
	if m._ToDepartmentLocation != nil {
		edges = append(edges, departmentlocation.EdgeToDepartmentLocation)
	}
	if m._Department != nil {
		edges = append(edges, departmentlocation.EdgeDepartment)
	}
	if m._Location != nil {
		edges = append(edges, departmentlocation.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case departmentlocation.EdgeAsset:
		ids := make([]ent.Value, 0, len(m._Asset))
		for id := range m._Asset {
			ids = append(ids, id)
		}
		return ids
	case departmentlocation.EdgeFromDepartmentLocation:
		ids := make([]ent.Value, 0, len(m._FromDepartmentLocation))
		for id := range m._FromDepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	case departmentlocation.EdgeToDepartmentLocation:
		ids := make([]ent.Value, 0, len(m._ToDepartmentLocation))
		for id := range m._ToDepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	case departmentlocation.EdgeDepartment:
		if id := m._Department; id != nil {
			return []ent.Value{*id}
		}
	case departmentlocation.EdgeLocation:
		if id := m._Location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_Asset != nil {
		edges = append(edges, departmentlocation.EdgeAsset)
	}
	if m.removed_FromDepartmentLocation != nil {
		edges = append(edges, departmentlocation.EdgeFromDepartmentLocation)
	}
	if m.removed_ToDepartmentLocation != nil {
		edges = append(edges, departmentlocation.EdgeToDepartmentLocation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentLocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case departmentlocation.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.removed_Asset))
		for id := range m.removed_Asset {
			ids = append(ids, id)
		}
		return ids
	case departmentlocation.EdgeFromDepartmentLocation:
		ids := make([]ent.Value, 0, len(m.removed_FromDepartmentLocation))
		for id := range m.removed_FromDepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	case departmentlocation.EdgeToDepartmentLocation:
		ids := make([]ent.Value, 0, len(m.removed_ToDepartmentLocation))
		for id := range m.removed_ToDepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_Asset {
		edges = append(edges, departmentlocation.EdgeAsset)
	}
	if m.cleared_FromDepartmentLocation {
		edges = append(edges, departmentlocation.EdgeFromDepartmentLocation)
	}
	if m.cleared_ToDepartmentLocation {
		edges = append(edges, departmentlocation.EdgeToDepartmentLocation)
	}
	if m.cleared_Department {
		edges = append(edges, departmentlocation.EdgeDepartment)
	}
	if m.cleared_Location {
		edges = append(edges, departmentlocation.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case departmentlocation.EdgeAsset:
		return m.cleared_Asset
	case departmentlocation.EdgeFromDepartmentLocation:
		return m.cleared_FromDepartmentLocation
	case departmentlocation.EdgeToDepartmentLocation:
		return m.cleared_ToDepartmentLocation
	case departmentlocation.EdgeDepartment:
		return m.cleared_Department
	case departmentlocation.EdgeLocation:
		return m.cleared_Location
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentLocationMutation) ClearEdge(name string) error {
	switch name {
	case departmentlocation.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case departmentlocation.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown DepartmentLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentLocationMutation) ResetEdge(name string) error {
	switch name {
	case departmentlocation.EdgeAsset:
		m.ResetAsset()
		return nil
	case departmentlocation.EdgeFromDepartmentLocation:
		m.ResetFromDepartmentLocation()
		return nil
	case departmentlocation.EdgeToDepartmentLocation:
		m.ResetToDepartmentLocation()
		return nil
	case departmentlocation.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case departmentlocation.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown DepartmentLocation edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_FirstName    *string
	_LastName     *string
	_Phone        *string
	clearedFields map[string]struct{}
	_Asset        map[int]struct{}
	removed_Asset map[int]struct{}
	cleared_Asset bool
	done          bool
	oldValue      func(context.Context) (*Employee, error)
	predicates    []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Employee entities.
func (m *EmployeeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "FirstName" field.
func (m *EmployeeMutation) SetFirstName(s string) {
	m._FirstName = &s
}

// FirstName returns the value of the "FirstName" field in the mutation.
func (m *EmployeeMutation) FirstName() (r string, exists bool) {
	v := m._FirstName
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "FirstName" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "FirstName" field.
func (m *EmployeeMutation) ResetFirstName() {
	m._FirstName = nil
}

// SetLastName sets the "LastName" field.
func (m *EmployeeMutation) SetLastName(s string) {
	m._LastName = &s
}

// LastName returns the value of the "LastName" field in the mutation.
func (m *EmployeeMutation) LastName() (r string, exists bool) {
	v := m._LastName
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "LastName" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "LastName" field.
func (m *EmployeeMutation) ResetLastName() {
	m._LastName = nil
}

// SetPhone sets the "Phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "Phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m._Phone = nil
}

// AddAssetIDs adds the "Asset" edge to the Asset entity by ids.
func (m *EmployeeMutation) AddAssetIDs(ids ...int) {
	if m._Asset == nil {
		m._Asset = make(map[int]struct{})
	}
	for i := range ids {
		m._Asset[ids[i]] = struct{}{}
	}
}

// ClearAsset clears the "Asset" edge to the Asset entity.
func (m *EmployeeMutation) ClearAsset() {
	m.cleared_Asset = true
}

// AssetCleared reports if the "Asset" edge to the Asset entity was cleared.
func (m *EmployeeMutation) AssetCleared() bool {
	return m.cleared_Asset
}

// RemoveAssetIDs removes the "Asset" edge to the Asset entity by IDs.
func (m *EmployeeMutation) RemoveAssetIDs(ids ...int) {
	if m.removed_Asset == nil {
		m.removed_Asset = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Asset, ids[i])
		m.removed_Asset[ids[i]] = struct{}{}
	}
}

// RemovedAsset returns the removed IDs of the "Asset" edge to the Asset entity.
func (m *EmployeeMutation) RemovedAssetIDs() (ids []int) {
	for id := range m.removed_Asset {
		ids = append(ids, id)
	}
	return
}

// AssetIDs returns the "Asset" edge IDs in the mutation.
func (m *EmployeeMutation) AssetIDs() (ids []int) {
	for id := range m._Asset {
		ids = append(ids, id)
	}
	return
}

// ResetAsset resets all changes to the "Asset" edge.
func (m *EmployeeMutation) ResetAsset() {
	m._Asset = nil
	m.cleared_Asset = false
	m.removed_Asset = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._FirstName != nil {
		fields = append(fields, employee.FieldFirstName)
	}
	if m._LastName != nil {
		fields = append(fields, employee.FieldLastName)
	}
	if m._Phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldFirstName:
		return m.FirstName()
	case employee.FieldLastName:
		return m.LastName()
	case employee.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldFirstName:
		return m.OldFirstName(ctx)
	case employee.FieldLastName:
		return m.OldLastName(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case employee.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldFirstName:
		m.ResetFirstName()
		return nil
	case employee.FieldLastName:
		m.ResetLastName()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Asset != nil {
		edges = append(edges, employee.EdgeAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeAsset:
		ids := make([]ent.Value, 0, len(m._Asset))
		for id := range m._Asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Asset != nil {
		edges = append(edges, employee.EdgeAsset)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeAsset:
		ids := make([]ent.Value, 0, len(m.removed_Asset))
		for id := range m.removed_Asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Asset {
		edges = append(edges, employee.EdgeAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeAsset:
		return m.cleared_Asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeAsset:
		m.ResetAsset()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Name                      *string
	clearedFields              map[string]struct{}
	_DepartmentLocation        map[int]struct{}
	removed_DepartmentLocation map[int]struct{}
	cleared_DepartmentLocation bool
	done                       bool
	oldValue                   func(context.Context) (*Location, error)
	predicates                 []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *LocationMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *LocationMutation) ResetName() {
	m._Name = nil
}

// AddDepartmentLocationIDs adds the "DepartmentLocation" edge to the DepartmentLocation entity by ids.
func (m *LocationMutation) AddDepartmentLocationIDs(ids ...int) {
	if m._DepartmentLocation == nil {
		m._DepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		m._DepartmentLocation[ids[i]] = struct{}{}
	}
}

// ClearDepartmentLocation clears the "DepartmentLocation" edge to the DepartmentLocation entity.
func (m *LocationMutation) ClearDepartmentLocation() {
	m.cleared_DepartmentLocation = true
}

// DepartmentLocationCleared reports if the "DepartmentLocation" edge to the DepartmentLocation entity was cleared.
func (m *LocationMutation) DepartmentLocationCleared() bool {
	return m.cleared_DepartmentLocation
}

// RemoveDepartmentLocationIDs removes the "DepartmentLocation" edge to the DepartmentLocation entity by IDs.
func (m *LocationMutation) RemoveDepartmentLocationIDs(ids ...int) {
	if m.removed_DepartmentLocation == nil {
		m.removed_DepartmentLocation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._DepartmentLocation, ids[i])
		m.removed_DepartmentLocation[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentLocation returns the removed IDs of the "DepartmentLocation" edge to the DepartmentLocation entity.
func (m *LocationMutation) RemovedDepartmentLocationIDs() (ids []int) {
	for id := range m.removed_DepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// DepartmentLocationIDs returns the "DepartmentLocation" edge IDs in the mutation.
func (m *LocationMutation) DepartmentLocationIDs() (ids []int) {
	for id := range m._DepartmentLocation {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentLocation resets all changes to the "DepartmentLocation" edge.
func (m *LocationMutation) ResetDepartmentLocation() {
	m._DepartmentLocation = nil
	m.cleared_DepartmentLocation = false
	m.removed_DepartmentLocation = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, location.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._DepartmentLocation != nil {
		edges = append(edges, location.EdgeDepartmentLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeDepartmentLocation:
		ids := make([]ent.Value, 0, len(m._DepartmentLocation))
		for id := range m._DepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_DepartmentLocation != nil {
		edges = append(edges, location.EdgeDepartmentLocation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeDepartmentLocation:
		ids := make([]ent.Value, 0, len(m.removed_DepartmentLocation))
		for id := range m.removed_DepartmentLocation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_DepartmentLocation {
		edges = append(edges, location.EdgeDepartmentLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeDepartmentLocation:
		return m.cleared_DepartmentLocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeDepartmentLocation:
		m.ResetDepartmentLocation()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}
